# 事务的隔离级别
    事务隔离级别有4种,分别是读未提交,读已提交(不可重复读),重复读,序列化, 这四种级别依次递增.  
- 读未提交(READ UNCOMMITTED)  
     
        事务中的修改,即使没有提交,对其他的事务也是可见的.这就导致事务可以读取未被提交的数据,也叫脏读. 这个级别会导致很多问题,并且这个级别的性能比没有比其他级别好太多,一般不会使用.  
    
- 读已提交(READ COMMITTED)  
        
        这种情况下,当前事务只能看见已提交事务做的修改(这里注意是修改,而不是新增).这个级别也叫不可重复读(NOREPEATABLE READ), 这是因为在这种情况下,执行两次同样的查询可能会得到不一样的结果. 这个级别依然没有解决脏读问题
        
- 可重复读(REPEATABLE READ)  

         这种级别的隔离能保证多个事务中多次读取同样记录的结果是一致的(读取相同的记录的情况下,记录的数据是一致的). 但这种情况下依然存在另外的问题,即幻读(Phantom Read). 所谓幻读就是当事务在读取某个范围的记录时, 此时另外的事务在该范围内新插入了新的记录,这时候会产生幻行(Phantom Row), 即读取到了新的记录. InnoDB和XtraDB通过多版本并发控制解决了幻读问题(待理解).  
         
- 串行化(SERIALIZABLE)  

        这是最高的隔离级别,这种情况下,所有的事务都被强制串行执行.这样能避免幻读问题(应该说所有问题?), 但带来更高的系统开销,以及降低了性能,这是因为在这个级别,读取的每一行数据都会加上锁,可能会导致大量的超时和锁争用的问题. 实际应用中很少会用到这个级别.         
<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>HashMap和ConcurrentHashMap的分析</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h2 id="hashmap%E5%92%8Cconcurrenthashmap%E7%9A%84%E5%88%86%E6%9E%90">HashMap和ConcurrentHashMap的分析</h2>
<h3 id="hashmap%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5">HashMap中一些字段</h3>
<ul>
<li>capacity: 容量,始终保持2^n, 可以扩容,扩容后数组大小为当前2倍</li>
<li>loadFactor: 负载因子, 默认0.75</li>
<li>threshold: 扩容阈值, 元素数量达到这么大后进行扩容</li>
</ul>
<h3 id="jdk7-hashmap%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE">JDK7 HashMap结构示意图</h3>
<p><img src="/jdk/struct/jdk7HashMap.png" alt="jdk7HashMap"></p>
<blockquote>
<p>基本上, HashMap是一个数组,每个数组元素都是一个单向列表, 列表元素类型是内部类Entry&lt;K,V&gt;, 包含四个属性, key, value, hash值和用于单向列表的next</p>
</blockquote>
<h3 id="jdk7-hashmap%E7%9A%84%E6%96%B9%E6%B3%95">JDK7 HashMap的方法</h3>
<ul>
<li>
<p>put(K key, V value)</p>
<pre><code>  这个方法用于往数组中插入数据    
  第一步,判断内部数组是不是未初始化过的空数组, 如果是,需要先初始化数组,初始化数组时, 将重新设置扩容阈值为初始化容量与负载因子的乘积.  
  接下来判断key是否为空,如果为空进入putForNullKey方法,设置空元素,这个元素的key是null, 且放在内部数组的第一个位置的链表上, 并返回key为null时的旧值, put方法结束  
  当key不为空,需要计算key的hash值, 并且取hash值二进制最后几位(具体几位与当前数组的长度有关, 计算方式是hash &amp; (table.length -1)), 将这个值作为元素将要放到数组的链表位置.  
  接下来有两种情况: 没有插入过这个key,和已经插入过.  
  没有插入过,将key和value插入到key对应的数组对应链表头部.  
  插入过又分为两种情况: key相同,key不同但hash相同(hash冲突).  
  key相同的情况: 设置新的值,并返回原来的值.  
  key的hash相同: 将新的值插入到原先的数组对应位置的链表头部  
</code></pre>
<blockquote>
<p>在往map中插入新值的时候会出现数组扩容的情况,触发条件是当前元素没有插入时,size &gt;= 扩容阈值, 并且key对应的数组位置上已经有值, 扩容后的数组大小是原先数组大小的两倍,并且,原先的链表上的每个元素key都需要重新计算hash值, 重新分配到数组上</p>
</blockquote>
</li>
<li>
<p>get(K key)</p>
<pre><code>  这个方法用于从map中获取数据, 这里分为key为null或不为空. 
  如果为空的话,执行getForNullKey()方法,这个方法会去数组第一个位置的链表中遍历出key为null的Entry. 
  如果不为空, 则执行getEntry方法, 计算hash,再计算hash在数组中的偏移量, 再对这个偏移量位置的链表进行遍历, 再将获取到的Entry的value返回   
</code></pre>
</li>
</ul>
<h3 id="jdk7-concurrenthashmap-%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE">JDK7 ConcurrentHashMap 结构示意图</h3>
<p><img src="/jdk/struct/jdk7ConcurrentHashMap.png" alt="jdk7ConcurrentHashMap"></p>
<blockquote>
<p>注意这里的segment, 分段锁.<br>
ConcurrentHashMap中包含的数组元素变为Segment类, 每个Segment中包含一个HashEntry&lt;K,V&gt;数组, 数组元素是一个单向列表, 也就是说,每个Segment看起来像一个小MAP<br>
这个MAP实现的接口也不一样,是ConCurrentMap&lt;K,V&gt;</p>
</blockquote>
<h3 id="jdk7-concurrenthashmap%E7%9A%84%E6%96%B9%E6%B3%95">JDK7 ConcurrentHashMap的方法</h3>
<ul>
<li>构造方法</li>
</ul>
<blockquote>
<p>这个方法主要是通过concurrentLevel计算并设置ConcurrentHashMap的segmentShift和segmentMask字段<br>
初始化Segment数组</p>
</blockquote>
<pre><code class="language-java"><div>    <span class="hljs-comment">/**
     * initialCapacity 初始化容量,这个容量是Map的总容量
     * loadFactor 负载因子,每个segment都有一个负载因子(为什么要放在Segment里)
     * concurrencyLevel 并发级别, 跟Segment数组的长度有关
     * */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity,
                             <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>{
        <span class="hljs-comment">//检查参数                        </span>
        <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();
        <span class="hljs-comment">//并发级别最大 2的16次方</span>
        <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)
            concurrencyLevel = MAX_SEGMENTS;
        <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span>
        <span class="hljs-comment">//这两个数纯粹用于计算下面的segmentShift和segmentMask</span>
        <span class="hljs-comment">//sshift是当ssize大于等于concurrentLevel时的指数</span>
        <span class="hljs-keyword">int</span> sshift = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> ssize = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) {
            ++sshift;
            ssize &lt;&lt;= <span class="hljs-number">1</span>;
        }
        <span class="hljs-comment">//Segment数组偏移量,跟插入时key的hash值位移有关</span>
        <span class="hljs-comment">//Segment掩码,key的hash值通过掩码最终获取是设置到哪个Segment中</span>
        <span class="hljs-comment">//segmentShift = 32 - n</span>
        <span class="hljs-comment">//segmentMask = $2^n$</span>
        <span class="hljs-keyword">this</span>.segmentShift = <span class="hljs-number">32</span> - sshift;
        <span class="hljs-keyword">this</span>.segmentMask = ssize - <span class="hljs-number">1</span>;
        <span class="hljs-comment">//最大容量约束</span>
        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        <span class="hljs-comment">//表示每个Segment中的HashEntry数组的大小</span>
        <span class="hljs-keyword">int</span> c = initialCapacity / ssize;
        <span class="hljs-comment">//这是确保 Segment数量和每个Segment的容量乘积不小于初始容量</span>
        <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)
            ++c;
        <span class="hljs-comment">//最小Segment中的长度为2, cap最终是2的幂</span>
        <span class="hljs-keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY;
        <span class="hljs-keyword">while</span> (cap &lt; c)
            cap &lt;&lt;= <span class="hljs-number">1</span>;
        <span class="hljs-comment">// 初始化Segment数组,并创建一个Segment作为数组的第一个元素</span>
        Segment&lt;K,V&gt; s0 =
            <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="hljs-keyword">int</span>)(cap * loadFactor),
                             (HashEntry&lt;K,V&gt;[])<span class="hljs-keyword">new</span> HashEntry[cap]);
        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Segment[ssize];
        <span class="hljs-comment">//原子操作, 将Segment写入Segment数组</span>
        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="hljs-comment">// ordered write of segments[0]</span>
        <span class="hljs-comment">//赋值到ConcurrentHashMap的segments字段</span>
        <span class="hljs-keyword">this</span>.segments = ss;
    }
</div></code></pre>
<ul>
<li>put方法</li>
</ul>
<pre><code class="language-java"><div><span class="hljs-comment">/**
 * 首先判空,如果value为空,抛出空指针, 所以concurrentHashMap不支持空value
 * */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>{
        Segment&lt;K,V&gt; s;
        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();
        <span class="hljs-comment">//计算key的hash值</span>
        <span class="hljs-keyword">int</span> hash = hash(key);
        <span class="hljs-comment">//hash在右移segmentShift位之后,只剩高位,高位数量就是segmentMask的2进制位数,而且segmentMask每一位都是1</span>
        <span class="hljs-keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
        <span class="hljs-keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="hljs-comment">// nonvolatile; recheck</span>
             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="hljs-keyword">null</span>) <span class="hljs-comment">//  in ensureSegment</span>
            s = ensureSegment(j);
        <span class="hljs-keyword">return</span> s.put(key, hash, value, <span class="hljs-keyword">false</span>);
    }
</div></code></pre>

    </body>
    </html>